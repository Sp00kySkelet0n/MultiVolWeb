# Very VERY VERY HACKY way of running shell commands... I had to implement this weird code because without a full TTY
# The json files generated by the CLI are empty... I don't have time to fix it right now.
from __future__ import annotations

import logging
from ..rxconfig import config
from typing import List
import asyncio
from pathlib import Path
import json, shlex, os, socket, docker, pty, fcntl, select, errno

logger = logging.getLogger(__name__)


def get_self_container():
    client = docker.DockerClient(base_url="unix://var/run/docker.sock")
    hostname = socket.gethostname()
    current_ip_address = socket.gethostbyname(hostname)
    for container in client.containers.list():
        info = container.attrs
        networks = info["NetworkSettings"]["Networks"]
        ip_address = next(iter(networks.values()))["IPAddress"]
        if current_ip_address == ip_address:
            return container
    return None


def get_host_mount_for(path_in_container):
    container = get_self_container()
    if not container:
        raise RuntimeError("Could not find self container from PID")
    for mount in container.attrs["Mounts"]:
        if mount["Destination"] == path_in_container:
            return Path(mount["Source"])
    return None


async def after_upload(
    state,
    uploaded_files_names: List[str],
    case_name: str,
    os_value: str,
    mode_value: str
):
    try:
        current_path_parent = Path(__file__).parent.parent
        cases_dir = current_path_parent / "cases"
        new_case_dir = cases_dir / case_name.replace(" ", "_")
        new_case_dir.mkdir(parents=True, exist_ok=True)
        state.log_append(f"New case directory created: {new_case_dir}")
        logger.info("New case directory created: %s", new_case_dir)
        yield
    except Exception as e:
        err = f"[ERROR] Failed to create case directory {new_case_dir}: {e}"
        state.log_append(err)
        logger.exception(err)
        yield
        return

    try:
        case_details_path = new_case_dir / "case_details.json"
        case_details = {
            "case_name": case_name,
            "case_details": "This is a test case for MultiVol",
            "case_os": os_value,
        }
        with case_details_path.open("w", encoding="utf-8") as f:
            json.dump(case_details, f, indent=4, ensure_ascii=False)
        msg = f"Wrote case details to {case_details_path}"
        state.log_append(msg)
        logger.info(msg)
        yield
    except Exception as e:
        err = f"[ERROR] Failed to write case_details.json: {e}"
        state.log_append(err)
        logger.exception(err)
        yield

    for upload_name in uploaded_files_names:
        try:
            state.log_append(f"File {upload_name} uploaded successfully.")
            logger.info("File %s uploaded successfully.", upload_name)
            yield

            multivol_script = Path(f"{config.cli_multivol_path}") / "main.py"

            if config.is_container == "True":
                symbols_path = get_host_mount_for(str(Path(__file__).parent.parent / "profiles_json"))
            else:
                symbols_path = Path(__file__).parent.parent / "profiles_json"

            if config.is_container == "True":
                uploads_mount = get_host_mount_for(str(Path(__file__).parent.parent.parent / "uploaded_files"))
                dump_path = f"{uploads_mount}/{str(upload_name).replace('uploaded_files/','')}"
            else:
                dump_path = str(Path(__file__).parent.parent.parent / "uploaded_files" / Path(str(upload_name)).name)

            state.log_append(f"Dump path is {dump_path}")

            if os_value == "linux":
                command = (
                    f"python3 {shlex.quote(str(multivol_script))} vol3 "
                    f"--dump {shlex.quote(str(dump_path))} "
                    f"--image volatility3 "
                    f"--{os_value} "
                    f"--output-path {shlex.quote(str(new_case_dir))} "
                    f"--symbols-path {shlex.quote(str(symbols_path))} "
                    f"--format json"
                )
            else:
                command = (
                    f"python3 {shlex.quote(str(multivol_script))} vol3 "
                    f"--dump {shlex.quote(str(dump_path))} "
                    f"--image volatility3 "
                    f"--{os_value} "
                    f"--{mode_value} "
                    f"--output-path {shlex.quote(str(new_case_dir))} "
                    f"--format json"
                )

            state.log_append(f"[EXECUTING] {command}")
            logger.info("Executing: %s", command)
            yield

            # ----- FULL PTY EXECUTION & STREAMING -----
            master_fd, slave_fd = pty.openpty()
            try:
                proc = await asyncio.create_subprocess_exec(
                    "/bin/bash", "-lc", command,
                    stdin=slave_fd, stdout=slave_fd, stderr=slave_fd,
                )
            finally:
                os.close(slave_fd)

            # make master non-blocking
            flags = fcntl.fcntl(master_fd, fcntl.F_GETFL)
            fcntl.fcntl(master_fd, fcntl.F_SETFL, flags | os.O_nonblock if hasattr(os, "O_nonblock") else os.O_NONBLOCK)

            wait_task = asyncio.create_task(proc.wait())
            buf = b""

            while True:
                r, _, _ = select.select([master_fd], [], [], 0.2)
                if master_fd in r:
                    try:
                        data = os.read(master_fd, 65536)
                    except OSError as e:
                        if e.errno not in (errno.EAGAIN, errno.EWOULDBLOCK):
                            raise
                        data = b""
                    if data:
                        buf += data
                        while True:
                            idx = buf.find(b"\n")
                            if idx == -1:
                                break
                            line = buf[:idx]
                            buf = buf[idx + 1 :]
                            text = line.decode(errors="ignore").rstrip("\r")
                            if text:
                                state.log_append(f"[post] {text}")
                                yield
                if wait_task.done():
                    # drain any remaining data quickly
                    while True:
                        r2, _, _ = select.select([master_fd], [], [], 0.05)
                        if master_fd not in r2:
                            break
                        try:
                            data = os.read(master_fd, 65536)
                        except OSError:
                            break
                        if not data:
                            break
                        buf += data
                        while True:
                            idx = buf.find(b"\n")
                            if idx == -1:
                                break
                            line = buf[:idx]
                            buf = buf[idx + 1 :]
                            text = line.decode(errors="ignore").rstrip("\r")
                            if text:
                                state.log_append(f"[post] {text}")
                                yield
                    break

            if buf:
                tail = buf.decode(errors="ignore").strip()
                if tail:
                    state.log_append(f"[post] {tail}")
                    yield

            rc = wait_task.result()
            os.close(master_fd)

            if rc == 0:
                state.log_append("[post] command succeeded")
                logger.info("Command succeeded.")
            else:
                state.log_append(f"[ERROR] command failed with return code {rc}")
                logger.error("Command failed with return code %s", rc)
            yield
            # ----- END PTY EXECUTION -----

        except Exception as e:
            err = f"[ERROR] Exception while processing {upload_name}: {e}"
            state.log_append(err)
            logger.exception(err)
            yield
